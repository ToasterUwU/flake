diff --git a/src/xrt/ipc/server/ipc_server_mainloop_android.c b/src/xrt/ipc/server/ipc_server_mainloop_android.c
index 96a04f6bc57c66698a16e95903937ed761ab32da..9fd9a1d1da4a80ed7f3b5f252d4fd6919a344247 100644
--- a/src/xrt/ipc/server/ipc_server_mainloop_android.c
+++ b/src/xrt/ipc/server/ipc_server_mainloop_android.c
@@ -31,9 +31,14 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
+#include <signal.h>
 
 #define SHUTTING_DOWN (-1)
 
+static volatile bool do_terminate;
+static sighandler_t orig_sigint_handler;
+static sighandler_t orig_sigterm_handler;
+
 /*
  *
  * Static functions.
@@ -107,6 +112,13 @@ handle_listen(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 	pthread_mutex_unlock(&ml->accept_mutex);
 }
 
+static void
+handle_signal(int sig)
+{
+	do_terminate = true;
+	return;
+}
+
 #define NUM_POLL_EVENTS 8
 #define NO_SLEEP 0
 
@@ -122,8 +134,18 @@ ipc_server_mainloop_poll(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 
 	struct epoll_event events[NUM_POLL_EVENTS] = {0};
 
-	// No sleeping, returns immediately.
-	int ret = epoll_wait(epoll_fd, events, NUM_POLL_EVENTS, NO_SLEEP);
+	int ret;
+	do {
+		if (do_terminate) {
+			do_terminate = false;
+			ipc_server_handle_shutdown_signal(vs);
+			return;
+		}
+
+		// No sleeping, returns immediately.
+		int ret = epoll_wait(epoll_fd, events, NUM_POLL_EVENTS, NO_SLEEP);
+	} while (vs->running && ret < 0 && errno == EINTR);
+
 	if (ret < 0) {
 		U_LOG_E("epoll_wait failed with '%i'.", ret);
 		ipc_server_handle_failure(vs);
@@ -153,12 +175,19 @@ ipc_server_mainloop_init(struct ipc_server_mainloop *ml, bool no_stdin)
 		return ret;
 	}
 
+	do_terminate = false;
+	orig_sigint_handler = signal(SIGINT, handle_signal);
+	orig_sigterm_handler = signal(SIGINT, handle_signal);
+
 	return 0;
 }
 
 void
 ipc_server_mainloop_deinit(struct ipc_server_mainloop *ml)
 {
+	signal(SIGINT, orig_sigterm_handler);
+	signal(SIGINT, orig_sigint_handler);
+
 	if (ml == NULL) {
 		return;
 	}
diff --git a/src/xrt/ipc/server/ipc_server_mainloop_linux.c b/src/xrt/ipc/server/ipc_server_mainloop_linux.c
index 36bf3e31dc937f9a5c6ccee47ac5c04a517e57bd..3d509e7979b1f07309e7381d05291f179e90af86 100644
--- a/src/xrt/ipc/server/ipc_server_mainloop_linux.c
+++ b/src/xrt/ipc/server/ipc_server_mainloop_linux.c
@@ -41,12 +41,17 @@
 #include <string.h>
 #include <assert.h>
 #include <limits.h>
+#include <signal.h>
 #include "util/u_debug.h"
 
 #ifdef XRT_HAVE_SYSTEMD
 #include <systemd/sd-daemon.h>
 #endif
 
+static volatile bool do_terminate;
+static sighandler_t orig_sigint_handler;
+static sighandler_t orig_sigterm_handler;
+
 
 /*
  *
@@ -217,6 +222,13 @@ handle_listen(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 	ipc_server_handle_client_connected(vs, ret);
 }
 
+static void
+handle_signal(int sig)
+{
+	do_terminate = true;
+	return;
+}
+
 #define NUM_POLL_EVENTS 8
 #define NO_SLEEP 0
 
@@ -235,8 +247,18 @@ ipc_server_mainloop_poll(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 
 	struct epoll_event events[NUM_POLL_EVENTS] = {0};
 
-	// No sleeping, returns immediately.
-	int ret = epoll_wait(epoll_fd, events, NUM_POLL_EVENTS, NO_SLEEP);
+	int ret;
+	do {
+		if (do_terminate) {
+			do_terminate = false;
+			ipc_server_handle_shutdown_signal(vs);
+			return;
+		}
+
+		// No sleeping, returns immediately.
+		ret = epoll_wait(epoll_fd, events, NUM_POLL_EVENTS, NO_SLEEP);
+	} while (vs->running && ret < 0 && errno == EINTR);
+
 	if (ret < 0) {
 		U_LOG_E("epoll_wait failed with '%i'.", ret);
 		ipc_server_handle_failure(vs);
@@ -273,6 +295,11 @@ ipc_server_mainloop_init(struct ipc_server_mainloop *ml, bool no_stdin)
 		ipc_server_mainloop_deinit(ml);
 		return ret;
 	}
+
+	do_terminate = false;
+	orig_sigint_handler = signal(SIGINT, handle_signal);
+	orig_sigterm_handler = signal(SIGINT, handle_signal);
+
 	return 0;
 }
 
@@ -281,6 +308,9 @@ ipc_server_mainloop_deinit(struct ipc_server_mainloop *ml)
 {
 	IPC_TRACE_MARKER();
 
+	signal(SIGINT, orig_sigterm_handler);
+	signal(SIGINT, orig_sigint_handler);
+
 	if (ml == NULL) {
 		return;
 	}
diff --git a/src/xrt/ipc/server/ipc_server_mainloop_windows.cpp b/src/xrt/ipc/server/ipc_server_mainloop_windows.cpp
index 2ea7bd9b216e4cec2eb64e224387b2bf3be48c3d..0c02e8236eff87f0fec2d0f81e722c83d852b5e9 100644
--- a/src/xrt/ipc/server/ipc_server_mainloop_windows.cpp
+++ b/src/xrt/ipc/server/ipc_server_mainloop_windows.cpp
@@ -36,6 +36,8 @@
 #include <conio.h>
 #include <sddl.h>
 
+static volatile BOOL do_terminate;
+
 
 /*
  *
@@ -207,6 +209,12 @@ handle_connected_client(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 	ipc_server_handle_failure(vs);
 }
 
+static BOOL WINAPI
+console_handler(DWORD ctrl_type)
+{
+	do_terminate = TRUE;
+}
+
 
 /*
  *
@@ -219,6 +227,12 @@ ipc_server_mainloop_poll(struct ipc_server *vs, struct ipc_server_mainloop *ml)
 {
 	IPC_TRACE_MARKER();
 
+	if (do_terminate) {
+		do_terminate = FALSE;
+		ipc_server_handle_shutdown_signal(vs);
+		return;
+	}
+
 	if (!vs->no_stdin && _kbhit()) {
 		U_LOG_E("console input! exiting...");
 		ipc_server_handle_shutdown_signal(vs);
@@ -278,6 +292,9 @@ ipc_server_mainloop_init(struct ipc_server_mainloop *ml, bool no_stdin)
 		goto err;
 	}
 
+	do_terminate = FALSE;
+	SetConsoleCtrlHandler(console_handler, TRUE);
+
 	return 0;
 
 err:
@@ -291,6 +308,8 @@ ipc_server_mainloop_deinit(struct ipc_server_mainloop *ml)
 {
 	IPC_TRACE_MARKER();
 
+	SetConsoleCtrlHandler(console_handler, FALSE);
+
 	if (ml->pipe_handle != INVALID_HANDLE_VALUE) {
 		CloseHandle(ml->pipe_handle);
 		ml->pipe_handle = INVALID_HANDLE_VALUE;
